apply(prior.temp,1,median,nr.rm=TRUE)
apply(prior.temp,1,median)
post.temp.median = apply(post.temp,1,median)
line(post.temp.median)
lines(post.temp.median)
post.temp.median = apply(post.temp,1,mean)
lines(post.temp.median)
plot(data$temp)
post.temp = apply(betas.post[1:1000,],1,reg_fun,time = data$time)
post.temp.median = apply(post.temp,1,median)
lines(post.temp.median)
denisty(post.temp)
densityy(post.temp)
density(post.temp)
quantile(post.temp)
?quantile
quantile(post.temp, probs = seq(0,1,0.025))
q = quantile(post.temp, probs = seq(0,1,0.025))
q
q = quantile(post.temp, probs = c(0.025,0.975))
q
q[1]
post.temp[post.temp > q[1]]
dim(post.temp)
post.temp = apply(betas.post[1:1000,],1,reg_fun,time = data$time)
post.temp.median = apply(post.temp,1,median)
lines(post.temp.median)
q = quantile(post.temp, probs = c(0.025,0.975))
post.temp.median = apply(post.temp,1,median)
lines(post.temp.median)
q = quantile(post.temp, probs = c(0.025,0.975))
post.temp.q1 = post.temp[post.temp > q[1]]
post.temp.median.q1 = apply(post.temp.q1,1,median)
dim(post.temp.q1)
post.temp.q1 = post.temp[which(post.temp > q[1])]
post.temp.median.q1 = apply(post.temp.q1,1,median)
dim(post.temp.q1)
post.temp.q1
post.temp.median.q1 = post.temp.median[post.temp.median > q1]
post.temp.median.q1 = post.temp.median[post.temp.median > q]
lines(post.temp.median.q1)
post.temp.median.q1 = post.temp.median[post.temp.median > q[1]]
lines(post.temp.median.q1)
plot(data$temp)
post.temp = apply(betas.post[1:1000,],1,reg_fun,time = data$time)
post.temp.median = apply(post.temp,1,median)
lines(post.temp.median)
q = quantile(post.temp, probs = c(0.025,0.975))
a = c(1,1,1)
dim(a)
post.temp.q1 = post.temp[which(post.temp > q[1]),]
post.temp.q1 = post.temp[which(post.temp[,1:1000] > q[1]),]
post.temp.q1 = post.temp[,which(post.temp[,1:1000] > q[1])]
post.temp.q1 = post.temp[which(post.temp[,1:1000] > q[1])]
post.temp.q1 = post.temp[post.temp[,1:1000] > q[1]]
post.temp[,1:1000]
post.temp.q1 = post.temp[post.temp > q[1],]
post.temp.q1 = post.temp[,post.temp > q[1]]
post.temp.q1 = apply(post.temp,1,post.temp[,post.temp > q[1]])
post.temp.q1 = apply(post.temp,1,post.temp[post.temp > q[1]])
filter = function(temp){
post.temp[,post.temp > q[1]]
}
post.temp.q1 = apply(post.temp,1,filter(post.temp))
filter = function(temp){
post.temp[post.temp > q[1]]
}
post.temp.q1 = apply(post.temp,1,filter(post.temp))
filter = function(temp){
temp[temp > q[1]]
}
post.temp.q1 = apply(post.temp,1,filter(post.temp))
post.temp.q1 = apply(post.temp,1,filter
post.temp.q1 = apply(post.temp,1,filter)
filter = function(temp){
return(temp[temp > q[1]])
}
post.temp.q1 = apply(post.temp,1,filter)
post.temp.median.q1 = apply(post.temp.q1,1,median)
lines(post.temp.q1)
View(post.temp.q1)
post.temp.q1
plot(data$temp)
post.temp = apply(betas.post[1:1000,],1,reg_fun,time = data$time)
post.temp.median = apply(post.temp,1,median)
lines(post.temp.median)
filter = function(temp){
return(temp > q[1])
}
post.temp.q1 = apply(post.temp,1,filter)
post.temp.median.q1 = apply(post.temp.q1,1,median)
post.temp[post.temp > q[1]]
post.temp[post.temp > q[1],]
post.temp[(post.temp > q[1]),]
a
a=as.matrix(1,2,3;456;789)
a=as.matrix(1,2,3;4,5,6;7,8,9)
a=as.matrix(1, 3, 3)
a
a=as.matrix(1:9,ncol=3,nrow=3)
a
?as.matrix
a=as.matrix(1:9,ncol=3,nrow=3, byrow=TRUE)
a
a=as.matrix(1,ncol=3,nrow=3, byrow=TRUE)
a
a=as.matrix(1:9,ncol=3,nrow=3, byrow=TRUE)
a
a[a<4]
a[a<4,]
a[,a<4]
median(c(1,2,NA,3))
median(c(1,2,NA,3),rm.na=TRUE)
median(c(1,2,NA,3),rm.na=FALSE)
median(c(1,1,NA,3),rm.na=FALSE)
median(c(1,2,NA,3),na.rm=TRUE)
dim(post.temp)
post.temp[,1:1000]
post.temp[,1:1000] == -12
post.temp[,1:1000] < -12
a = post.temp[,1:1000] < -12
a
a = post.temp[post.temp[,1:1000] < -12]
a
a = post.temp[post.temp[,1:1000] > -12]
a
sort(post.temp)[q[1]:q[2]]
sort(post.temp)
sort(post.temp, drop=FALSE)
a = post.temp[post.temp[,1:1000] > -12,drop=FALSE]
a
a = post.temp[post.temp[,1:1000] > -12,drop=TRUE]
a
a = post.temp[post.temp[,1:1000,drop=FALSE] > -12,drop=TRUE]
a
a = apply(post.temp,1,quantile,prob = c(0.025,0.0975),na.rm=TRUE)
a
post.temp.q1 = apply(post.temp,1,quantile,prob = c(0.025,0.975),na.rm=TRUE)
a = apply(post.temp,1,quantile,prob = c(0.025,0.0975),na.rm=TRUE)
View(post.temp.q1)
post.temp.q = apply(post.temp,1,quantile,prob = c(0.025,0.975),na.rm=TRUE)
lines(post.temp.q[1])
lines(post.temp.q[,1])
lines(post.temp.q[,2])
lines(post.temp.q[1,])
lines(post.temp.q[2,])
post.temp.q = apply(post.temp,1,quantile,prob = c(0.025,0.975),na.rm=TRUE)
lines(post.temp.q[1,])
lines(post.temp.q[2,])
lines(post.temp.q[1,],col = "red")
lines(post.temp.q[2,],col = "blue")
?quantile
post.temp.q = apply(post.temp,1,quantile,probs = c(0.025,0.975),na.rm=TRUE) #How does this work??
lines(post.temp.q[1,],col = "red")
lines(post.temp.q[2,],col = "blue")
data =read.delim("/home/ponsv690/Documents/TDDE07/Lab2/TempLinkoping.txt")
set.seed(235)
## 1a
Ndraws = 10000
mu_0 = t(data.frame(-15,150,-150))
Omega_0 = 1*diag(3)
nu_0 = 40
var_0 = 1
var<-(nu_0*var_0)/rchisq(Ndraws,nu_0)
hist(var,freq = FALSE)
beta = matrix(0,Ndraws,3)
library(mvtnorm)
sim.beta = function(sigma2, mu, omega){
rmvnorm(n=1,mean=mu,sigma=sigma2*solve(omega))
}
betas = sapply(var,sim.beta,mu = mu_0, omega = Omega_0)
betas = t(betas)
reg_fun =function(betas,time){
#FRÅGA!!!!!: Hur får man in epsilon i ekvationen?
temp = betas[1] + betas[2]*time + betas[3]*time^2
return(temp)
}
prior.temp = apply(betas[seq(1,25,1),],1,reg_fun, time = data$time)
x = dim(prior.temp)[1]
x.axis = (1:x) / x
#FRÅGA!!!!: Hur tätt ska kurvorna ligga varandra?
plot(x.axis,prior.temp[,1],type = "l", xlab = "Time", ylab = "Temperature",ylim=c(-20,30))
for (i in 2:25) {
lines(x.axis,prior.temp[,i])
}
## 1b
X = cbind(rep(1,length(data$time)),data$time,data$time^2)
X.prim.X = t(X)%*%X
beta.hat = solve(t(X)%*%X)%*%t(X)%*%data$temp
mu_n = solve((t(X)%*%X + Omega_0))%*%(t(X)%*%X%*%beta.hat + Omega_0%*%mu_0)
Omega_n = X.prim.X + Omega_0
nu_n = nu_0 + dim(X)[1]
nuvar_n = nu_0%*%var_0 + (t(data$temp)%*%data$temp + t(mu_0)%*%Omega_0%*%mu_0 - t(mu_n)%*%Omega_n%*%mu_n)
var_n = as.numeric(nuvar_n/nu_n)
var.post = (nu_n*var_n)/rchisq(Ndraws,nu_n)
hist(var.post) #DOES IT LOOK GOOD??
betas.post = sapply(var.post,sim.beta, mu = mu_n, omega = Omega_n)
betas.post = t(betas.post)
hist(betas[,1])
hist(betas[,2])
hist(betas[,3])
plot(data$temp)
post.temp = apply(betas.post[1:1000,],1,reg_fun,time = data$time)
post.temp.median = apply(post.temp,1,median)
lines(post.temp.median)
post.temp.q = apply(post.temp,1,quantile,probs = c(0.025,0.975),na.rm=TRUE) #How does this work??
lines(post.temp.q[1,],col = "red")
lines(post.temp.q[2,],col = "blue")
## 1c
post.temp.q = apply(post.temp.median,1,quantile,probs = c(0.025,0.975),na.rm=TRUE) #How does this work??
post.temp.q = apply(post.temp,1,quantile,probs = c(0.025,0.975),na.rm=TRUE) #How does this work??
lines(post.temp.q[1,],col = "red")
lines(post.temp.q[2,],col = "blue")
data =read.delim("/home/ponsv690/Documents/TDDE07/Lab2/TempLinkoping.txt")
set.seed(235)
## 1a
Ndraws = 10000
mu_0 = t(data.frame(-15,150,-150))
Omega_0 = 1*diag(3)
nu_0 = 40
var_0 = 1
var<-(nu_0*var_0)/rchisq(Ndraws,nu_0)
hist(var,freq = FALSE)
beta = matrix(0,Ndraws,3)
library(mvtnorm)
sim.beta = function(sigma2, mu, omega){
rmvnorm(n=1,mean=mu,sigma=sigma2*solve(omega))
}
betas = sapply(var,sim.beta,mu = mu_0, omega = Omega_0)
betas = t(betas)
reg_fun =function(betas,time){
#FRÅGA!!!!!: Hur får man in epsilon i ekvationen?
temp = betas[1] + betas[2]*time + betas[3]*time^2
return(temp)
}
prior.temp = apply(betas[seq(1,25,1),],1,reg_fun, time = data$time)
x = dim(prior.temp)[1]
x.axis = (1:x) / x
#FRÅGA!!!!: Hur tätt ska kurvorna ligga varandra?
plot(x.axis,prior.temp[,1],type = "l", xlab = "Time", ylab = "Temperature",ylim=c(-20,30))
for (i in 2:25) {
lines(x.axis,prior.temp[,i])
}
## 1b
X = cbind(rep(1,length(data$time)),data$time,data$time^2)
X.prim.X = t(X)%*%X
beta.hat = solve(t(X)%*%X)%*%t(X)%*%data$temp
mu_n = solve((t(X)%*%X + Omega_0))%*%(t(X)%*%X%*%beta.hat + Omega_0%*%mu_0)
Omega_n = X.prim.X + Omega_0
nu_n = nu_0 + dim(X)[1]
nuvar_n = nu_0%*%var_0 + (t(data$temp)%*%data$temp + t(mu_0)%*%Omega_0%*%mu_0 - t(mu_n)%*%Omega_n%*%mu_n)
var_n = as.numeric(nuvar_n/nu_n)
var.post = (nu_n*var_n)/rchisq(Ndraws,nu_n)
hist(var.post) #DOES IT LOOK GOOD??
betas.post = sapply(var.post,sim.beta, mu = mu_n, omega = Omega_n)
betas.post = t(betas.post)
hist(betas[,1])
hist(betas[,2])
hist(betas[,3])
plot(data$temp)
post.temp = apply(betas.post[1:1000,],1,reg_fun,time = data$time)
post.temp.median = apply(post.temp,1,median)
lines(post.temp.median)
post.temp.q = apply(post.temp,1,quantile,probs = c(0.025,0.975),na.rm=TRUE) #How does this work??
lines(post.temp.q[1,],col = "red")
lines(post.temp.q[2,],col = "blue")
## 1c
data =read.delim("/home/krisi211/Desktop/TDDE07/Lab2/TempLinkoping.txt")
data =read.delim("/home/krisi211/Desktop/TDDE07/Lab2/TempLinkoping.txt")
set.seed(235)
## 1a
Ndraws = 10000
mu_0 = t(data.frame(-15,150,-150))
Omega_0 = 1*diag(3)
nu_0 = 40
var_0 = 1
var<-(nu_0*var_0)/rchisq(Ndraws,nu_0)
hist(var,freq = FALSE)
beta = matrix(0,Ndraws,3)
library(mvtnorm)
sim.beta = function(sigma2, mu, omega){
rmvnorm(n=1,mean=mu,sigma=sigma2*solve(omega))
}
betas = sapply(var,sim.beta,mu = mu_0, omega = Omega_0)
betas = t(betas)
reg_fun =function(betas,time){
#FRÅGA!!!!!: Hur får man in epsilon i ekvationen?
temp = betas[1] + betas[2]*time + betas[3]*time^2
return(temp)
}
prior.temp = apply(betas[seq(1,25,1),],1,reg_fun, time = data$time)
x = dim(prior.temp)[1]
x.axis = (1:x) / x
#FRÅGA!!!!: Hur tätt ska kurvorna ligga varandra?
plot(x.axis,prior.temp[,1],type = "l", xlab = "Time", ylab = "Temperature",ylim=c(-20,30))
for (i in 2:25) {
lines(x.axis,prior.temp[,i])
}
## 1b
X = cbind(rep(1,length(data$time)),data$time,data$time^2)
X.prim.X = t(X)%*%X
beta.hat = solve(t(X)%*%X)%*%t(X)%*%data$temp
mu_n = solve((t(X)%*%X + Omega_0))%*%(t(X)%*%X%*%beta.hat + Omega_0%*%mu_0)
Omega_n = X.prim.X + Omega_0
nu_n = nu_0 + dim(X)[1]
nuvar_n = nu_0%*%var_0 + (t(data$temp)%*%data$temp + t(mu_0)%*%Omega_0%*%mu_0 - t(mu_n)%*%Omega_n%*%mu_n)
var_n = as.numeric(nuvar_n/nu_n)
var.post = (nu_n*var_n)/rchisq(Ndraws,nu_n)
hist(var.post) #DOES IT LOOK GOOD??
betas.post = sapply(var.post,sim.beta, mu = mu_n, omega = Omega_n)
betas.post = t(betas.post)
hist(betas[,1])
hist(betas[,2])
hist(betas[,3])
plot(data$temp)
post.temp = apply(betas.post[1:1000,],1,reg_fun,time = data$time)
post.temp.median = apply(post.temp,1,median)
lines(post.temp.median)
post.temp.q = apply(post.temp,1,quantile,probs = c(0.025,0.975),na.rm=TRUE) #How does this work??
lines(post.temp.q[1,],col = "red")
lines(post.temp.q[2,],col = "blue")
## 1c
help(optim)
mode(post.temp)
mode(post.temp[1,])
mode(post.temp[,1])
posterior.mode(post.temp)
max(post.temp)
max(data$temp)
max(post.temp[1,])
max(post.temp[,1])
max(post.temp[,1:10])
max(post.temp)
## 1c
temp.prim = betas[2] + 2*betas[3]*data$time
plot(temp.prim)
t = betas[2]/(2*betas[3])
t = -betas[2]/(2*betas[3])
betas[2,]
betas[,2]
t = -betas[,2]/(2*betas[,3])
## 1c
temp.prim = betas[,2] + 2*betas[,3]*data$time
t = -betas[,2]/(2*betas[,3])
density(t)
plot(density(t))
## 1c
t = -betas[,2]/(2*betas[,3])
plot(density(t))
denisty(t)$y
a = denisty(t)
a = density(t)
a$y
a$x
a$y
a$x
density(t)$y
plot(density(t)$x*366,density(t))
plot(density(t)$x*366,density(t)$y)
plot(density(t)$x*366,density(t)$y,type="l")
plot(density(t)$x*366,density(t)$y,type="l",xlab = "Days", ylab = "Max Temp dist")
## 1c
time = -betas[,2]/(2*betas[,3])
plot(density(t)$x*366,density(t)$y,type="l",xlab = "Days", ylab = "Max Temp dist")
plot(density(time)$x*366,density(time)$y,type="l",xlab = "Days", ylab = "Max Temp dist")
m = matrix(100,3,3)
m
solve(m)
m = m*1*diag(3)
m
solve(m)
m[3,3]=10000000
m
solve(m)
read.delim("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat")
data = read.delim("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat")
glm.model = glm(Work~0 +., data = data, family = binomial)
?glm
View(data)
data = read.table("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat")
View(data)
View(data)
data = read.LInes("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat")
View(data)
data = read.Lines("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat")
data = readLInes("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat")
data = readLines("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat")
View(data)
data = read.delim2("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat")
View(data)
data = read.delim("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat",sep="")
View(data)
glm.model = glm(Work~0 +., data = data, family = binomial)
library("mvtnorm")
data = read.delim("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat",sep="")
View(data)
## a
glm.model = glm(Work~0 +., data = data, family = binomial)
## b
tau = 10
library("mvtnorm")
y <- as.vector(Data[,1]) # Data from the read.table function is a data frame. Let's convert y and X to vector and matrix.
y <- as.vector(data[,1]) # Data from the read.table function is a data frame. Let's convert y and X to vector and matrix.
X <- as.matrix(data[,2:9])
names
names(data)
X
dim(X)
?optim
?dmvnorm
library("mvtnorm")
?dmvnorm
matrix(0,params,1)
params = dim(X)[2]
matrix(0,params,1)
a = matrix(0,params,1)
dim(a)
data = read.delim("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat",sep="")
## a
glm.model = glm(Work~0 +., data = data, family = binomial)
## b
tau = 10
library("mvtnorm")
y = as.vector(data[,1]) # Data from the read.table function is a data frame. Let's convert y and X to vector and matrix.
X = as.matrix(data[,2:9])
params = dim(X)[2]
mu = as.vector(rep(0,params))
Sigma = tau^2*diag(params)
LogPostLogistic = function(betas, y, X, Sigma) { # Kan ni kugga oss för det här?
params = length(betas)
linPred = X%*%betas
logLik = sum(linPred*y -log(1+exp(linPred)))
if (abs(logLik) == Inf) logLik = -20001
logPrior = dmvnorm(betas, matrix(0, params, 1), Sigma, log=TRUE)
return(logLik + logPrior)
}
#data = read.delim("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat",sep="")
data = read.delim("/home/ponsv690/Documents/TDDE07/Lab2/WomenWork.dat",sep="")
## a
glm.model = glm(Work~0 +., data = data, family = binomial)
## b
tau = 10
library("mvtnorm")
y = as.vector(data[,1]) # Data from the read.table function is a data frame. Let's convert y and X to vector and matrix.
X = as.matrix(data[,2:9])
params = dim(X)[2]
mu = as.vector(rep(0,params))
Sigma = tau^2*diag(params)
LogPostLogistic = function(betas, y, X, Sigma) { # Kan ni kugga oss för det här?
params = length(betas)
linPred = X%*%betas
logLik = sum(linPred*y -log(1+exp(linPred)))
if (abs(logLik) == Inf) logLik = -20001
logPrior = dmvnorm(betas, matrix(0, params, 1), Sigma, log=TRUE)
return(logLik + logPrior)
}
initVal <- c(rep(0,dim(X)[2]))
OptimResults = optim(initVal,logPost,gr=NULL,y,X,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
OptimResults = optim(initVal,LogPostLogistic,gr=NULL,y,X,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
#data = read.delim("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat",sep="")
data = read.delim("/home/ponsv690/Documents/TDDE07/Lab2/WomenWork.dat",sep="")
## a
glm.model = glm(Work~0 +., data = data, family = binomial)
## b
tau = 10
library("mvtnorm")
y = as.vector(data[,1]) # Data from the read.table function is a data frame. Let's convert y and X to vector and matrix.
X = as.matrix(data[,2:9])
params = dim(X)[2]
mu = as.vector(rep(0,params))
Sigma = tau^2*diag(params)
LogPostLogistic = function(betas, y, X, mu, Sigma) { # Kan ni kugga oss för det här?
params = length(betas)
linPred = X%*%betas
logLik = sum(linPred*y -log(1+exp(linPred)))
if (abs(logLik) == Inf) logLik = -20001
logPrior = dmvnorm(betas, matrix(0, params, 1), Sigma, log=TRUE)
return(logLik + logPrior)
}
initVal = c(rep(0,dim(X)[2]))
OptimResults = optim(initVal,LogPostLogistic,gr=NULL,y,X,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
?optim
mu = matrix(0,params,1)
#data = read.delim("/home/krisi211/Desktop/TDDE07/Lab2/WomenWork.dat",sep="")
data = read.delim("/home/ponsv690/Documents/TDDE07/Lab2/WomenWork.dat",sep="")
## a
glm.model = glm(Work~0 +., data = data, family = binomial)
## b
tau = 10
library("mvtnorm")
y = as.vector(data[,1]) # Data from the read.table function is a data frame. Let's convert y and X to vector and matrix.
X = as.matrix(data[,2:9])
params = dim(X)[2]
mu = matrix(0,params,1)
Sigma = tau^2*diag(params)
LogPostLogistic = function(betas, y, X, mu, Sigma) { # Kan ni kugga oss för det här?
params = length(betas)
linPred = X%*%betas
logLik = sum(linPred*y -log(1+exp(linPred)))
if (abs(logLik) == Inf) logLik = -20001
logPrior = dmvnorm(betas, mu, Sigma, log=TRUE)
return(logLik + logPrior)
}
initVal = c(rep(0,dim(X)[2]))
OptimResults = optim(initVal,LogPostLogistic,gr=NULL,y,X,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
View(OptimResults)
beta.tilde = OptimResults$par
inv.hessian = solve(OptimResults$hessian)
numerical.beta = rmvnorm(10000,beta.tilde,inv.hessian)
?rmvnorm
numerical.beta = rmvnorm(10000,beta.tilde,inv.hessian)
hist(numerical.beta)
